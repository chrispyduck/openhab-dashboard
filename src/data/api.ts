/**
 * openHAB REST API
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* eslint-disable */

import localVarRequest from "request";
import * as http from "http";

let defaultBasePath = 'https://localhost/rest';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */
let primitives = [
                    "string",
                    "boolean",
                    "double",
                    "integer",
                    "long",
                    "float",
                    "number",
                    "any"
                 ];

class ObjectSerializer {

    public static findCorrectType(data: any, expectedType: string) {
        if (data == undefined) {
            return expectedType;
        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
            return expectedType;
        } else if (expectedType === "Date") {
            return expectedType;
        } else {
            if (enumsMap[expectedType]) {
                return expectedType;
            }

            if (!typeMap[expectedType]) {
                return expectedType; // w/e we don't know the type
            }

            // Check the discriminator
            let discriminatorProperty = typeMap[expectedType].discriminator;
            if (discriminatorProperty == null) {
                return expectedType; // the type does not have a discriminator. use it.
            } else {
                if (data[discriminatorProperty]) {
                    return data[discriminatorProperty]; // use the type given in the discriminator
                } else {
                    return expectedType; // discriminator was not present (or an empty string)
                }
            }
        }
    }

    public static serialize(data: any, type: string) {
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.serialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return data.toString();
        } else {
            if (enumsMap[type]) {
                return data;
            }
            if (!typeMap[type]) { // in case we dont know the type
                return data;
            }

            // get the map for the correct type.
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            let instance: {[index: string]: any} = {};
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type);
            }
            return instance;
        }
    }

    public static deserialize(data: any, type: string) {
        // polymorphism may change the actual type.
        type = ObjectSerializer.findCorrectType(data, type);
        if (data == undefined) {
            return data;
        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
            return data;
        } else if (type.lastIndexOf("Array<", 0) === 0) { // string.startsWith pre es6
            let subType: string = type.replace("Array<", ""); // Array<Type> => Type>
            subType = subType.substring(0, subType.length - 1); // Type> => Type
            let transformedData: any[] = [];
            for (let index in data) {
                let date = data[index];
                transformedData.push(ObjectSerializer.deserialize(date, subType));
            }
            return transformedData;
        } else if (type === "Date") {
            return new Date(data);
        } else {
            if (enumsMap[type]) {// is Enum
                return data;
            }

            if (!typeMap[type]) { // dont know the type
                return data;
            }
            let instance = new typeMap[type]();
            let attributeTypes = typeMap[type].getAttributeTypeMap();
            for (let index in attributeTypes) {
                let attributeType = attributeTypes[index];
                instance[attributeType.name] = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type);
            }
            return instance;
        }
    }
}

export class ActionDTO {
    'id'?: string;
    'label'?: string;
    'description'?: string;
    'configuration'?: { [key: string]: any; };
    'type'?: string;
    'inputs'?: { [key: string]: string; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "configuration",
            "baseName": "configuration",
            "type": "{ [key: string]: any; }"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "inputs",
            "baseName": "inputs",
            "type": "{ [key: string]: string; }"
        }    ];

    static getAttributeTypeMap() {
        return ActionDTO.attributeTypeMap;
    }
}

export class AudioSinkDTO {
    'id'?: string;
    'label'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AudioSinkDTO.attributeTypeMap;
    }
}

export class AudioSourceDTO {
    'id'?: string;
    'label'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return AudioSourceDTO.attributeTypeMap;
    }
}

export class BindingInfoDTO {
    'author'?: string;
    'description'?: string;
    'id'?: string;
    'name'?: string;
    'configDescriptionURI'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "author",
            "baseName": "author",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "configDescriptionURI",
            "baseName": "configDescriptionURI",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return BindingInfoDTO.attributeTypeMap;
    }
}

export class ChannelDTO {
    'uid'?: string;
    'id'?: string;
    'channelTypeUID'?: string;
    'itemType'?: string;
    'kind'?: string;
    'label'?: string;
    'description'?: string;
    'defaultTags'?: Array<string>;
    'properties'?: { [key: string]: string; };
    'configuration'?: { [key: string]: any; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "uid",
            "baseName": "uid",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "channelTypeUID",
            "baseName": "channelTypeUID",
            "type": "string"
        },
        {
            "name": "itemType",
            "baseName": "itemType",
            "type": "string"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "defaultTags",
            "baseName": "defaultTags",
            "type": "Array<string>"
        },
        {
            "name": "properties",
            "baseName": "properties",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "configuration",
            "baseName": "configuration",
            "type": "{ [key: string]: any; }"
        }    ];

    static getAttributeTypeMap() {
        return ChannelDTO.attributeTypeMap;
    }
}

export class ChannelDefinitionDTO {
    'description'?: string;
    'id'?: string;
    'label'?: string;
    'tags'?: Array<string>;
    'properties'?: { [key: string]: string; };
    'category'?: string;
    'stateDescription'?: StateDescription;
    'advanced'?: boolean;
    'typeUID'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "properties",
            "baseName": "properties",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        },
        {
            "name": "stateDescription",
            "baseName": "stateDescription",
            "type": "StateDescription"
        },
        {
            "name": "advanced",
            "baseName": "advanced",
            "type": "boolean"
        },
        {
            "name": "typeUID",
            "baseName": "typeUID",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ChannelDefinitionDTO.attributeTypeMap;
    }
}

export class ChannelGroupDefinitionDTO {
    'id'?: string;
    'description'?: string;
    'label'?: string;
    'channels'?: Array<ChannelDefinitionDTO>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "channels",
            "baseName": "channels",
            "type": "Array<ChannelDefinitionDTO>"
        }    ];

    static getAttributeTypeMap() {
        return ChannelGroupDefinitionDTO.attributeTypeMap;
    }
}

export class ChannelTypeDTO {
    'parameters'?: Array<ConfigDescriptionParameterDTO>;
    'parameterGroups'?: Array<ConfigDescriptionParameterGroupDTO>;
    'description'?: string;
    'label'?: string;
    'category'?: string;
    'itemType'?: string;
    'kind'?: string;
    'stateDescription'?: StateDescription;
    'tags'?: Array<string>;
    'UID'?: string;
    'advanced'?: boolean;
    'commandDescription'?: CommandDescription;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "parameters",
            "baseName": "parameters",
            "type": "Array<ConfigDescriptionParameterDTO>"
        },
        {
            "name": "parameterGroups",
            "baseName": "parameterGroups",
            "type": "Array<ConfigDescriptionParameterGroupDTO>"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        },
        {
            "name": "itemType",
            "baseName": "itemType",
            "type": "string"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "stateDescription",
            "baseName": "stateDescription",
            "type": "StateDescription"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "UID",
            "baseName": "UID",
            "type": "string"
        },
        {
            "name": "advanced",
            "baseName": "advanced",
            "type": "boolean"
        },
        {
            "name": "commandDescription",
            "baseName": "commandDescription",
            "type": "CommandDescription"
        }    ];

    static getAttributeTypeMap() {
        return ChannelTypeDTO.attributeTypeMap;
    }
}

export class CommandDescription {
    'commandOptions'?: Array<CommandOption>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "commandOptions",
            "baseName": "commandOptions",
            "type": "Array<CommandOption>"
        }    ];

    static getAttributeTypeMap() {
        return CommandDescription.attributeTypeMap;
    }
}

export class CommandOption {
    'command'?: string;
    'label'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "command",
            "baseName": "command",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return CommandOption.attributeTypeMap;
    }
}

export class ConditionDTO {
    'id'?: string;
    'label'?: string;
    'description'?: string;
    'configuration'?: { [key: string]: any; };
    'type'?: string;
    'inputs'?: { [key: string]: string; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "configuration",
            "baseName": "configuration",
            "type": "{ [key: string]: any; }"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "inputs",
            "baseName": "inputs",
            "type": "{ [key: string]: string; }"
        }    ];

    static getAttributeTypeMap() {
        return ConditionDTO.attributeTypeMap;
    }
}

export class ConfigDescriptionDTO {
    'uri'?: string;
    'parameters'?: Array<ConfigDescriptionParameterDTO>;
    'parameterGroups'?: Array<ConfigDescriptionParameterGroupDTO>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "uri",
            "baseName": "uri",
            "type": "string"
        },
        {
            "name": "parameters",
            "baseName": "parameters",
            "type": "Array<ConfigDescriptionParameterDTO>"
        },
        {
            "name": "parameterGroups",
            "baseName": "parameterGroups",
            "type": "Array<ConfigDescriptionParameterGroupDTO>"
        }    ];

    static getAttributeTypeMap() {
        return ConfigDescriptionDTO.attributeTypeMap;
    }
}

export class ConfigDescriptionParameterDTO {
    'context'?: string;
    'defaultValue'?: string;
    'description'?: string;
    'label'?: string;
    'name'?: string;
    'required'?: boolean;
    'type'?: ConfigDescriptionParameterDTO.TypeEnum;
    'min'?: number;
    'max'?: number;
    'stepsize'?: number;
    'pattern'?: string;
    'readOnly'?: boolean;
    'multiple'?: boolean;
    'multipleLimit'?: number;
    'groupName'?: string;
    'advanced'?: boolean;
    'verify'?: boolean;
    'limitToOptions'?: boolean;
    'unit'?: string;
    'unitLabel'?: string;
    'options'?: Array<ParameterOptionDTO>;
    'filterCriteria'?: Array<FilterCriteriaDTO>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "context",
            "baseName": "context",
            "type": "string"
        },
        {
            "name": "defaultValue",
            "baseName": "defaultValue",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "required",
            "baseName": "required",
            "type": "boolean"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "ConfigDescriptionParameterDTO.TypeEnum"
        },
        {
            "name": "min",
            "baseName": "min",
            "type": "number"
        },
        {
            "name": "max",
            "baseName": "max",
            "type": "number"
        },
        {
            "name": "stepsize",
            "baseName": "stepsize",
            "type": "number"
        },
        {
            "name": "pattern",
            "baseName": "pattern",
            "type": "string"
        },
        {
            "name": "readOnly",
            "baseName": "readOnly",
            "type": "boolean"
        },
        {
            "name": "multiple",
            "baseName": "multiple",
            "type": "boolean"
        },
        {
            "name": "multipleLimit",
            "baseName": "multipleLimit",
            "type": "number"
        },
        {
            "name": "groupName",
            "baseName": "groupName",
            "type": "string"
        },
        {
            "name": "advanced",
            "baseName": "advanced",
            "type": "boolean"
        },
        {
            "name": "verify",
            "baseName": "verify",
            "type": "boolean"
        },
        {
            "name": "limitToOptions",
            "baseName": "limitToOptions",
            "type": "boolean"
        },
        {
            "name": "unit",
            "baseName": "unit",
            "type": "string"
        },
        {
            "name": "unitLabel",
            "baseName": "unitLabel",
            "type": "string"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "Array<ParameterOptionDTO>"
        },
        {
            "name": "filterCriteria",
            "baseName": "filterCriteria",
            "type": "Array<FilterCriteriaDTO>"
        }    ];

    static getAttributeTypeMap() {
        return ConfigDescriptionParameterDTO.attributeTypeMap;
    }
}

export declare namespace ConfigDescriptionParameterDTO {
    export enum TypeEnum {
        TEXT = 'TEXT',
        INTEGER = 'INTEGER',
        DECIMAL = 'DECIMAL',
        BOOLEAN = 'BOOLEAN'
    }
}
export class ConfigDescriptionParameterGroupDTO {
    'name'?: string;
    'context'?: string;
    'advanced'?: boolean;
    'label'?: string;
    'description'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "context",
            "baseName": "context",
            "type": "string"
        },
        {
            "name": "advanced",
            "baseName": "advanced",
            "type": "boolean"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ConfigDescriptionParameterGroupDTO.attributeTypeMap;
    }
}

export class ConfigurableServiceDTO {
    'id'?: string;
    'label'?: string;
    'category'?: string;
    'configDescriptionURI'?: string;
    'multiple'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        },
        {
            "name": "configDescriptionURI",
            "baseName": "configDescriptionURI",
            "type": "string"
        },
        {
            "name": "multiple",
            "baseName": "multiple",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return ConfigurableServiceDTO.attributeTypeMap;
    }
}

export class DiscoveryResultDTO {
    'bridgeUID'?: string;
    'flag'?: DiscoveryResultDTO.FlagEnum;
    'label'?: string;
    'properties'?: { [key: string]: any; };
    'representationProperty'?: string;
    'thingUID'?: string;
    'thingTypeUID'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "bridgeUID",
            "baseName": "bridgeUID",
            "type": "string"
        },
        {
            "name": "flag",
            "baseName": "flag",
            "type": "DiscoveryResultDTO.FlagEnum"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "properties",
            "baseName": "properties",
            "type": "{ [key: string]: any; }"
        },
        {
            "name": "representationProperty",
            "baseName": "representationProperty",
            "type": "string"
        },
        {
            "name": "thingUID",
            "baseName": "thingUID",
            "type": "string"
        },
        {
            "name": "thingTypeUID",
            "baseName": "thingTypeUID",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return DiscoveryResultDTO.attributeTypeMap;
    }
}

export declare namespace DiscoveryResultDTO {
    export enum FlagEnum {
        NEW = 'NEW',
        IGNORED = 'IGNORED'
    }
}
export class EnrichedItemDTO {
    'type'?: string;
    'name'?: string;
    'label'?: string;
    'category'?: string;
    'tags'?: Array<string>;
    'groupNames'?: Array<string>;
    'link'?: string;
    'state'?: string;
    'transformedState'?: string;
    'stateDescription'?: StateDescription;
    'commandDescription'?: CommandDescription;
    'metadata'?: { [key: string]: any; };
    'editable'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "groupNames",
            "baseName": "groupNames",
            "type": "Array<string>"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "transformedState",
            "baseName": "transformedState",
            "type": "string"
        },
        {
            "name": "stateDescription",
            "baseName": "stateDescription",
            "type": "StateDescription"
        },
        {
            "name": "commandDescription",
            "baseName": "commandDescription",
            "type": "CommandDescription"
        },
        {
            "name": "metadata",
            "baseName": "metadata",
            "type": "{ [key: string]: any; }"
        },
        {
            "name": "editable",
            "baseName": "editable",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return EnrichedItemDTO.attributeTypeMap;
    }
}

export class EnrichedRuleDTO {
    'triggers'?: Array<TriggerDTO>;
    'conditions'?: Array<ConditionDTO>;
    'actions'?: Array<ActionDTO>;
    'configuration'?: { [key: string]: any; };
    'configDescriptions'?: Array<ConfigDescriptionParameterDTO>;
    'templateUID'?: string;
    'uid'?: string;
    'name'?: string;
    'tags'?: Array<string>;
    'visibility'?: EnrichedRuleDTO.VisibilityEnum;
    'description'?: string;
    'status'?: RuleStatusInfo;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "triggers",
            "baseName": "triggers",
            "type": "Array<TriggerDTO>"
        },
        {
            "name": "conditions",
            "baseName": "conditions",
            "type": "Array<ConditionDTO>"
        },
        {
            "name": "actions",
            "baseName": "actions",
            "type": "Array<ActionDTO>"
        },
        {
            "name": "configuration",
            "baseName": "configuration",
            "type": "{ [key: string]: any; }"
        },
        {
            "name": "configDescriptions",
            "baseName": "configDescriptions",
            "type": "Array<ConfigDescriptionParameterDTO>"
        },
        {
            "name": "templateUID",
            "baseName": "templateUID",
            "type": "string"
        },
        {
            "name": "uid",
            "baseName": "uid",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "visibility",
            "baseName": "visibility",
            "type": "EnrichedRuleDTO.VisibilityEnum"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "status",
            "baseName": "status",
            "type": "RuleStatusInfo"
        }    ];

    static getAttributeTypeMap() {
        return EnrichedRuleDTO.attributeTypeMap;
    }
}

export declare namespace EnrichedRuleDTO {
    export enum VisibilityEnum {
        VISIBLE = 'VISIBLE',
        HIDDEN = 'HIDDEN',
        EXPERT = 'EXPERT'
    }
}
export class EnrichedThingDTO {
    'label'?: string;
    'bridgeUID'?: string;
    'configuration'?: { [key: string]: any; };
    'properties'?: { [key: string]: string; };
    'UID'?: string;
    'thingTypeUID'?: string;
    'channels'?: Array<ChannelDTO>;
    'location'?: string;
    'statusInfo'?: ThingStatusInfo;
    'firmwareStatus'?: FirmwareStatusDTO;
    'editable'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "bridgeUID",
            "baseName": "bridgeUID",
            "type": "string"
        },
        {
            "name": "configuration",
            "baseName": "configuration",
            "type": "{ [key: string]: any; }"
        },
        {
            "name": "properties",
            "baseName": "properties",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "UID",
            "baseName": "UID",
            "type": "string"
        },
        {
            "name": "thingTypeUID",
            "baseName": "thingTypeUID",
            "type": "string"
        },
        {
            "name": "channels",
            "baseName": "channels",
            "type": "Array<ChannelDTO>"
        },
        {
            "name": "location",
            "baseName": "location",
            "type": "string"
        },
        {
            "name": "statusInfo",
            "baseName": "statusInfo",
            "type": "ThingStatusInfo"
        },
        {
            "name": "firmwareStatus",
            "baseName": "firmwareStatus",
            "type": "FirmwareStatusDTO"
        },
        {
            "name": "editable",
            "baseName": "editable",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return EnrichedThingDTO.attributeTypeMap;
    }
}

export class EventOutput {
    'type'?: Type;
    'closed'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "Type"
        },
        {
            "name": "closed",
            "baseName": "closed",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return EventOutput.attributeTypeMap;
    }
}

export class FilterCriteriaDTO {
    'value'?: string;
    'name'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FilterCriteriaDTO.attributeTypeMap;
    }
}

export class FirmwareStatusDTO {
    'status'?: string;
    'updatableVersion'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "string"
        },
        {
            "name": "updatableVersion",
            "baseName": "updatableVersion",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return FirmwareStatusDTO.attributeTypeMap;
    }
}

export class GroupFunctionDTO {
    'name'?: string;
    'params'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "params",
            "baseName": "params",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return GroupFunctionDTO.attributeTypeMap;
    }
}

export class GroupItemDTO {
    'type'?: string;
    'name'?: string;
    'label'?: string;
    'category'?: string;
    'tags'?: Array<string>;
    'groupNames'?: Array<string>;
    'groupType'?: string;
    '_function'?: GroupFunctionDTO;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "groupNames",
            "baseName": "groupNames",
            "type": "Array<string>"
        },
        {
            "name": "groupType",
            "baseName": "groupType",
            "type": "string"
        },
        {
            "name": "_function",
            "baseName": "function",
            "type": "GroupFunctionDTO"
        }    ];

    static getAttributeTypeMap() {
        return GroupItemDTO.attributeTypeMap;
    }
}

export class HistoryDataBean {
    'time'?: number;
    'state'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "time",
            "baseName": "time",
            "type": "number"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return HistoryDataBean.attributeTypeMap;
    }
}

export class HumanLanguageInterpreterDTO {
    'id'?: string;
    'label'?: string;
    'locales'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "locales",
            "baseName": "locales",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return HumanLanguageInterpreterDTO.attributeTypeMap;
    }
}

export class ItemChannelLinkDTO {
    'itemName'?: string;
    'channelUID'?: string;
    'configuration'?: { [key: string]: any; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "itemName",
            "baseName": "itemName",
            "type": "string"
        },
        {
            "name": "channelUID",
            "baseName": "channelUID",
            "type": "string"
        },
        {
            "name": "configuration",
            "baseName": "configuration",
            "type": "{ [key: string]: any; }"
        }    ];

    static getAttributeTypeMap() {
        return ItemChannelLinkDTO.attributeTypeMap;
    }
}

export class ItemHistoryDTO {
    'name'?: string;
    'totalrecords'?: string;
    'datapoints'?: string;
    'data'?: Array<HistoryDataBean>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "totalrecords",
            "baseName": "totalrecords",
            "type": "string"
        },
        {
            "name": "datapoints",
            "baseName": "datapoints",
            "type": "string"
        },
        {
            "name": "data",
            "baseName": "data",
            "type": "Array<HistoryDataBean>"
        }    ];

    static getAttributeTypeMap() {
        return ItemHistoryDTO.attributeTypeMap;
    }
}

export class MappingDTO {
    'command'?: string;
    'label'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "command",
            "baseName": "command",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return MappingDTO.attributeTypeMap;
    }
}

export class MetadataDTO {
    'value'?: string;
    'config'?: { [key: string]: any; };

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "config",
            "baseName": "config",
            "type": "{ [key: string]: any; }"
        }    ];

    static getAttributeTypeMap() {
        return MetadataDTO.attributeTypeMap;
    }
}

export class ModuleDTO {
    'id'?: string;
    'label'?: string;
    'description'?: string;
    'configuration'?: { [key: string]: any; };
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "configuration",
            "baseName": "configuration",
            "type": "{ [key: string]: any; }"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ModuleDTO.attributeTypeMap;
    }
}

export class ModuleTypeDTO {
    'uid'?: string;
    'visibility'?: ModuleTypeDTO.VisibilityEnum;
    'tags'?: Array<string>;
    'label'?: string;
    'description'?: string;
    'configDescriptions'?: Array<ConfigDescriptionParameterDTO>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "uid",
            "baseName": "uid",
            "type": "string"
        },
        {
            "name": "visibility",
            "baseName": "visibility",
            "type": "ModuleTypeDTO.VisibilityEnum"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "configDescriptions",
            "baseName": "configDescriptions",
            "type": "Array<ConfigDescriptionParameterDTO>"
        }    ];

    static getAttributeTypeMap() {
        return ModuleTypeDTO.attributeTypeMap;
    }
}

export declare namespace ModuleTypeDTO {
    export enum VisibilityEnum {
        VISIBLE = 'VISIBLE',
        HIDDEN = 'HIDDEN',
        EXPERT = 'EXPERT'
    }
}
export class PageDTO {
    'id'?: string;
    'title'?: string;
    'icon'?: string;
    'link'?: string;
    'parent'?: PageDTO;
    'leaf'?: boolean;
    'timeout'?: boolean;
    'widgets'?: Array<WidgetDTO>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "title",
            "baseName": "title",
            "type": "string"
        },
        {
            "name": "icon",
            "baseName": "icon",
            "type": "string"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "parent",
            "baseName": "parent",
            "type": "PageDTO"
        },
        {
            "name": "leaf",
            "baseName": "leaf",
            "type": "boolean"
        },
        {
            "name": "timeout",
            "baseName": "timeout",
            "type": "boolean"
        },
        {
            "name": "widgets",
            "baseName": "widgets",
            "type": "Array<WidgetDTO>"
        }    ];

    static getAttributeTypeMap() {
        return PageDTO.attributeTypeMap;
    }
}

export class ParameterOptionDTO {
    'label'?: string;
    'value'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ParameterOptionDTO.attributeTypeMap;
    }
}

export class ProfileTypeDTO {
    'uid'?: string;
    'label'?: string;
    'kind'?: string;
    'supportedItemTypes'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "uid",
            "baseName": "uid",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "kind",
            "baseName": "kind",
            "type": "string"
        },
        {
            "name": "supportedItemTypes",
            "baseName": "supportedItemTypes",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return ProfileTypeDTO.attributeTypeMap;
    }
}

export class RuleDTO {
    'triggers'?: Array<TriggerDTO>;
    'conditions'?: Array<ConditionDTO>;
    'actions'?: Array<ActionDTO>;
    'configuration'?: { [key: string]: any; };
    'configDescriptions'?: Array<ConfigDescriptionParameterDTO>;
    'templateUID'?: string;
    'uid'?: string;
    'name'?: string;
    'tags'?: Array<string>;
    'visibility'?: RuleDTO.VisibilityEnum;
    'description'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "triggers",
            "baseName": "triggers",
            "type": "Array<TriggerDTO>"
        },
        {
            "name": "conditions",
            "baseName": "conditions",
            "type": "Array<ConditionDTO>"
        },
        {
            "name": "actions",
            "baseName": "actions",
            "type": "Array<ActionDTO>"
        },
        {
            "name": "configuration",
            "baseName": "configuration",
            "type": "{ [key: string]: any; }"
        },
        {
            "name": "configDescriptions",
            "baseName": "configDescriptions",
            "type": "Array<ConfigDescriptionParameterDTO>"
        },
        {
            "name": "templateUID",
            "baseName": "templateUID",
            "type": "string"
        },
        {
            "name": "uid",
            "baseName": "uid",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "visibility",
            "baseName": "visibility",
            "type": "RuleDTO.VisibilityEnum"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RuleDTO.attributeTypeMap;
    }
}

export declare namespace RuleDTO {
    export enum VisibilityEnum {
        VISIBLE = 'VISIBLE',
        HIDDEN = 'HIDDEN',
        EXPERT = 'EXPERT'
    }
}
export class RuleStatusInfo {
    'status'?: RuleStatusInfo.StatusEnum;
    'statusDetail'?: RuleStatusInfo.StatusDetailEnum;
    'description'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "RuleStatusInfo.StatusEnum"
        },
        {
            "name": "statusDetail",
            "baseName": "statusDetail",
            "type": "RuleStatusInfo.StatusDetailEnum"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return RuleStatusInfo.attributeTypeMap;
    }
}

export declare namespace RuleStatusInfo {
    export enum StatusEnum {
        UNINITIALIZED = 'UNINITIALIZED',
        INITIALIZING = 'INITIALIZING',
        IDLE = 'IDLE',
        RUNNING = 'RUNNING'
    }
    export enum StatusDetailEnum {
        NONE = 'NONE',
        HANDLERMISSINGERROR = 'HANDLER_MISSING_ERROR',
        HANDLERINITIALIZINGERROR = 'HANDLER_INITIALIZING_ERROR',
        CONFIGURATIONERROR = 'CONFIGURATION_ERROR',
        TEMPLATEMISSINGERROR = 'TEMPLATE_MISSING_ERROR',
        INVALIDRULE = 'INVALID_RULE',
        DISABLED = 'DISABLED'
    }
}
export class SitemapDTO {
    'name'?: string;
    'icon'?: string;
    'label'?: string;
    'link'?: string;
    'homepage'?: PageDTO;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "icon",
            "baseName": "icon",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "link",
            "baseName": "link",
            "type": "string"
        },
        {
            "name": "homepage",
            "baseName": "homepage",
            "type": "PageDTO"
        }    ];

    static getAttributeTypeMap() {
        return SitemapDTO.attributeTypeMap;
    }
}

export class StateDescription {
    'minimum'?: number;
    'maximum'?: number;
    'step'?: number;
    'pattern'?: string;
    'readOnly'?: boolean;
    'options'?: Array<StateOption>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "minimum",
            "baseName": "minimum",
            "type": "number"
        },
        {
            "name": "maximum",
            "baseName": "maximum",
            "type": "number"
        },
        {
            "name": "step",
            "baseName": "step",
            "type": "number"
        },
        {
            "name": "pattern",
            "baseName": "pattern",
            "type": "string"
        },
        {
            "name": "readOnly",
            "baseName": "readOnly",
            "type": "boolean"
        },
        {
            "name": "options",
            "baseName": "options",
            "type": "Array<StateOption>"
        }    ];

    static getAttributeTypeMap() {
        return StateDescription.attributeTypeMap;
    }
}

export class StateOption {
    'value'?: string;
    'label'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "value",
            "baseName": "value",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return StateOption.attributeTypeMap;
    }
}

export class StrippedThingTypeDTO {
    'UID'?: string;
    'label'?: string;
    'description'?: string;
    'category'?: string;
    'listed'?: boolean;
    'supportedBridgeTypeUIDs'?: Array<string>;
    'bridge'?: boolean;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "UID",
            "baseName": "UID",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        },
        {
            "name": "listed",
            "baseName": "listed",
            "type": "boolean"
        },
        {
            "name": "supportedBridgeTypeUIDs",
            "baseName": "supportedBridgeTypeUIDs",
            "type": "Array<string>"
        },
        {
            "name": "bridge",
            "baseName": "bridge",
            "type": "boolean"
        }    ];

    static getAttributeTypeMap() {
        return StrippedThingTypeDTO.attributeTypeMap;
    }
}

export class Template {
    'description'?: string;
    'tags'?: Array<string>;
    'label'?: string;
    'visibility'?: Template.VisibilityEnum;
    'uid'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "tags",
            "baseName": "tags",
            "type": "Array<string>"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "visibility",
            "baseName": "visibility",
            "type": "Template.VisibilityEnum"
        },
        {
            "name": "uid",
            "baseName": "uid",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Template.attributeTypeMap;
    }
}

export declare namespace Template {
    export enum VisibilityEnum {
        VISIBLE = 'VISIBLE',
        HIDDEN = 'HIDDEN',
        EXPERT = 'EXPERT'
    }
}
export class ThingDTO {
    'label'?: string;
    'bridgeUID'?: string;
    'configuration'?: { [key: string]: any; };
    'properties'?: { [key: string]: string; };
    'UID'?: string;
    'thingTypeUID'?: string;
    'channels'?: Array<ChannelDTO>;
    'location'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "bridgeUID",
            "baseName": "bridgeUID",
            "type": "string"
        },
        {
            "name": "configuration",
            "baseName": "configuration",
            "type": "{ [key: string]: any; }"
        },
        {
            "name": "properties",
            "baseName": "properties",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "UID",
            "baseName": "UID",
            "type": "string"
        },
        {
            "name": "thingTypeUID",
            "baseName": "thingTypeUID",
            "type": "string"
        },
        {
            "name": "channels",
            "baseName": "channels",
            "type": "Array<ChannelDTO>"
        },
        {
            "name": "location",
            "baseName": "location",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ThingDTO.attributeTypeMap;
    }
}

export class ThingStatusInfo {
    'status'?: ThingStatusInfo.StatusEnum;
    'statusDetail'?: ThingStatusInfo.StatusDetailEnum;
    'description'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "status",
            "baseName": "status",
            "type": "ThingStatusInfo.StatusEnum"
        },
        {
            "name": "statusDetail",
            "baseName": "statusDetail",
            "type": "ThingStatusInfo.StatusDetailEnum"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return ThingStatusInfo.attributeTypeMap;
    }
}

export declare namespace ThingStatusInfo {
    export enum StatusEnum {
        UNINITIALIZED = 'UNINITIALIZED',
        INITIALIZING = 'INITIALIZING',
        UNKNOWN = 'UNKNOWN',
        ONLINE = 'ONLINE',
        OFFLINE = 'OFFLINE',
        REMOVING = 'REMOVING',
        REMOVED = 'REMOVED'
    }
    export enum StatusDetailEnum {
        NONE = 'NONE',
        HANDLERMISSINGERROR = 'HANDLER_MISSING_ERROR',
        HANDLERREGISTERINGERROR = 'HANDLER_REGISTERING_ERROR',
        HANDLERINITIALIZINGERROR = 'HANDLER_INITIALIZING_ERROR',
        HANDLERCONFIGURATIONPENDING = 'HANDLER_CONFIGURATION_PENDING',
        CONFIGURATIONPENDING = 'CONFIGURATION_PENDING',
        COMMUNICATIONERROR = 'COMMUNICATION_ERROR',
        CONFIGURATIONERROR = 'CONFIGURATION_ERROR',
        BRIDGEOFFLINE = 'BRIDGE_OFFLINE',
        FIRMWAREUPDATING = 'FIRMWARE_UPDATING',
        DUTYCYCLE = 'DUTY_CYCLE',
        BRIDGEUNINITIALIZED = 'BRIDGE_UNINITIALIZED',
        GONE = 'GONE',
        DISABLED = 'DISABLED'
    }
}
export class ThingTypeDTO {
    'UID'?: string;
    'label'?: string;
    'description'?: string;
    'category'?: string;
    'listed'?: boolean;
    'supportedBridgeTypeUIDs'?: Array<string>;
    'bridge'?: boolean;
    'channels'?: Array<ChannelDefinitionDTO>;
    'channelGroups'?: Array<ChannelGroupDefinitionDTO>;
    'configParameters'?: Array<ConfigDescriptionParameterDTO>;
    'parameterGroups'?: Array<ConfigDescriptionParameterGroupDTO>;
    'properties'?: { [key: string]: string; };
    'extensibleChannelTypeIds'?: Array<string>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "UID",
            "baseName": "UID",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "category",
            "baseName": "category",
            "type": "string"
        },
        {
            "name": "listed",
            "baseName": "listed",
            "type": "boolean"
        },
        {
            "name": "supportedBridgeTypeUIDs",
            "baseName": "supportedBridgeTypeUIDs",
            "type": "Array<string>"
        },
        {
            "name": "bridge",
            "baseName": "bridge",
            "type": "boolean"
        },
        {
            "name": "channels",
            "baseName": "channels",
            "type": "Array<ChannelDefinitionDTO>"
        },
        {
            "name": "channelGroups",
            "baseName": "channelGroups",
            "type": "Array<ChannelGroupDefinitionDTO>"
        },
        {
            "name": "configParameters",
            "baseName": "configParameters",
            "type": "Array<ConfigDescriptionParameterDTO>"
        },
        {
            "name": "parameterGroups",
            "baseName": "parameterGroups",
            "type": "Array<ConfigDescriptionParameterGroupDTO>"
        },
        {
            "name": "properties",
            "baseName": "properties",
            "type": "{ [key: string]: string; }"
        },
        {
            "name": "extensibleChannelTypeIds",
            "baseName": "extensibleChannelTypeIds",
            "type": "Array<string>"
        }    ];

    static getAttributeTypeMap() {
        return ThingTypeDTO.attributeTypeMap;
    }
}

export class TriggerDTO {
    'id'?: string;
    'label'?: string;
    'description'?: string;
    'configuration'?: { [key: string]: any; };
    'type'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "description",
            "baseName": "description",
            "type": "string"
        },
        {
            "name": "configuration",
            "baseName": "configuration",
            "type": "{ [key: string]: any; }"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return TriggerDTO.attributeTypeMap;
    }
}

export class Type {
    'typeName'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "typeName",
            "baseName": "typeName",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return Type.attributeTypeMap;
    }
}

export class VoiceDTO {
    'id'?: string;
    'label'?: string;
    'locale'?: string;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "id",
            "baseName": "id",
            "type": "string"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "locale",
            "baseName": "locale",
            "type": "string"
        }    ];

    static getAttributeTypeMap() {
        return VoiceDTO.attributeTypeMap;
    }
}

export class WidgetDTO {
    'widgetId'?: string;
    'type'?: string;
    'name'?: string;
    'visibility'?: boolean;
    'label'?: string;
    'icon'?: string;
    'labelcolor'?: string;
    'valuecolor'?: string;
    'mappings'?: Array<MappingDTO>;
    'switchSupport'?: boolean;
    'sendFrequency'?: number;
    'separator'?: string;
    'refresh'?: number;
    'height'?: number;
    'minValue'?: number;
    'maxValue'?: number;
    'step'?: number;
    'url'?: string;
    'encoding'?: string;
    'service'?: string;
    'period'?: string;
    'legend'?: boolean;
    'state'?: string;
    'item'?: EnrichedItemDTO;
    'linkedPage'?: PageDTO;
    'widgets'?: Array<WidgetDTO>;

    static discriminator: string | undefined = undefined;

    static attributeTypeMap: Array<{name: string, baseName: string, type: string}> = [
        {
            "name": "widgetId",
            "baseName": "widgetId",
            "type": "string"
        },
        {
            "name": "type",
            "baseName": "type",
            "type": "string"
        },
        {
            "name": "name",
            "baseName": "name",
            "type": "string"
        },
        {
            "name": "visibility",
            "baseName": "visibility",
            "type": "boolean"
        },
        {
            "name": "label",
            "baseName": "label",
            "type": "string"
        },
        {
            "name": "icon",
            "baseName": "icon",
            "type": "string"
        },
        {
            "name": "labelcolor",
            "baseName": "labelcolor",
            "type": "string"
        },
        {
            "name": "valuecolor",
            "baseName": "valuecolor",
            "type": "string"
        },
        {
            "name": "mappings",
            "baseName": "mappings",
            "type": "Array<MappingDTO>"
        },
        {
            "name": "switchSupport",
            "baseName": "switchSupport",
            "type": "boolean"
        },
        {
            "name": "sendFrequency",
            "baseName": "sendFrequency",
            "type": "number"
        },
        {
            "name": "separator",
            "baseName": "separator",
            "type": "string"
        },
        {
            "name": "refresh",
            "baseName": "refresh",
            "type": "number"
        },
        {
            "name": "height",
            "baseName": "height",
            "type": "number"
        },
        {
            "name": "minValue",
            "baseName": "minValue",
            "type": "number"
        },
        {
            "name": "maxValue",
            "baseName": "maxValue",
            "type": "number"
        },
        {
            "name": "step",
            "baseName": "step",
            "type": "number"
        },
        {
            "name": "url",
            "baseName": "url",
            "type": "string"
        },
        {
            "name": "encoding",
            "baseName": "encoding",
            "type": "string"
        },
        {
            "name": "service",
            "baseName": "service",
            "type": "string"
        },
        {
            "name": "period",
            "baseName": "period",
            "type": "string"
        },
        {
            "name": "legend",
            "baseName": "legend",
            "type": "boolean"
        },
        {
            "name": "state",
            "baseName": "state",
            "type": "string"
        },
        {
            "name": "item",
            "baseName": "item",
            "type": "EnrichedItemDTO"
        },
        {
            "name": "linkedPage",
            "baseName": "linkedPage",
            "type": "PageDTO"
        },
        {
            "name": "widgets",
            "baseName": "widgets",
            "type": "Array<WidgetDTO>"
        }    ];

    static getAttributeTypeMap() {
        return WidgetDTO.attributeTypeMap;
    }
}


let enumsMap: {[index: string]: any} = {
        "ConfigDescriptionParameterDTO.TypeEnum": ConfigDescriptionParameterDTO.TypeEnum,
        "DiscoveryResultDTO.FlagEnum": DiscoveryResultDTO.FlagEnum,
        "EnrichedRuleDTO.VisibilityEnum": EnrichedRuleDTO.VisibilityEnum,
        "ModuleTypeDTO.VisibilityEnum": ModuleTypeDTO.VisibilityEnum,
        "RuleDTO.VisibilityEnum": RuleDTO.VisibilityEnum,
        "RuleStatusInfo.StatusEnum": RuleStatusInfo.StatusEnum,
        "RuleStatusInfo.StatusDetailEnum": RuleStatusInfo.StatusDetailEnum,
        "Template.VisibilityEnum": Template.VisibilityEnum,
        "ThingStatusInfo.StatusEnum": ThingStatusInfo.StatusEnum,
        "ThingStatusInfo.StatusDetailEnum": ThingStatusInfo.StatusDetailEnum,
}

let typeMap: {[index: string]: any} = {
    "ActionDTO": ActionDTO,
    "AudioSinkDTO": AudioSinkDTO,
    "AudioSourceDTO": AudioSourceDTO,
    "BindingInfoDTO": BindingInfoDTO,
    "ChannelDTO": ChannelDTO,
    "ChannelDefinitionDTO": ChannelDefinitionDTO,
    "ChannelGroupDefinitionDTO": ChannelGroupDefinitionDTO,
    "ChannelTypeDTO": ChannelTypeDTO,
    "CommandDescription": CommandDescription,
    "CommandOption": CommandOption,
    "ConditionDTO": ConditionDTO,
    "ConfigDescriptionDTO": ConfigDescriptionDTO,
    "ConfigDescriptionParameterDTO": ConfigDescriptionParameterDTO,
    "ConfigDescriptionParameterGroupDTO": ConfigDescriptionParameterGroupDTO,
    "ConfigurableServiceDTO": ConfigurableServiceDTO,
    "DiscoveryResultDTO": DiscoveryResultDTO,
    "EnrichedItemDTO": EnrichedItemDTO,
    "EnrichedRuleDTO": EnrichedRuleDTO,
    "EnrichedThingDTO": EnrichedThingDTO,
    "EventOutput": EventOutput,
    "FilterCriteriaDTO": FilterCriteriaDTO,
    "FirmwareStatusDTO": FirmwareStatusDTO,
    "GroupFunctionDTO": GroupFunctionDTO,
    "GroupItemDTO": GroupItemDTO,
    "HistoryDataBean": HistoryDataBean,
    "HumanLanguageInterpreterDTO": HumanLanguageInterpreterDTO,
    "ItemChannelLinkDTO": ItemChannelLinkDTO,
    "ItemHistoryDTO": ItemHistoryDTO,
    "MappingDTO": MappingDTO,
    "MetadataDTO": MetadataDTO,
    "ModuleDTO": ModuleDTO,
    "ModuleTypeDTO": ModuleTypeDTO,
    "PageDTO": PageDTO,
    "ParameterOptionDTO": ParameterOptionDTO,
    "ProfileTypeDTO": ProfileTypeDTO,
    "RuleDTO": RuleDTO,
    "RuleStatusInfo": RuleStatusInfo,
    "SitemapDTO": SitemapDTO,
    "StateDescription": StateDescription,
    "StateOption": StateOption,
    "StrippedThingTypeDTO": StrippedThingTypeDTO,
    "Template": Template,
    "ThingDTO": ThingDTO,
    "ThingStatusInfo": ThingStatusInfo,
    "ThingTypeDTO": ThingTypeDTO,
    "TriggerDTO": TriggerDTO,
    "Type": Type,
    "VoiceDTO": VoiceDTO,
    "WidgetDTO": WidgetDTO,
}

export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: localVarRequest.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string = '';

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string = '';

    applyToRequest(requestOptions: localVarRequest.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string = '';
    public password: string = '';

    applyToRequest(_: localVarRequest.Options): void {
        // Do nothing
    }
}

export enum AudioApiApiKeys {
}

export class AudioApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: AudioApiApiKeys, value: string) {
        (this.authentications as any)[AudioApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get the default sink if defined or the first available sink.
     * @param acceptLanguage language
     * @param {*} [options] Override http request options.
     */
    public getDefaultSink (acceptLanguage?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/audio/defaultsink';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the default source if defined or the first available source.
     * @param acceptLanguage language
     * @param {*} [options] Override http request options.
     */
    public getDefaultSource (acceptLanguage?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/audio/defaultsource';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the list of all sinks.
     * @param acceptLanguage language
     * @param {*} [options] Override http request options.
     */
    public getSinks (acceptLanguage?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/audio/sinks';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the list of all sources.
     * @param acceptLanguage language
     * @param {*} [options] Override http request options.
     */
    public getSources (acceptLanguage?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/audio/sources';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum BindingsApiApiKeys {
}

export class BindingsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: BindingsApiApiKeys, value: string) {
        (this.authentications as any)[BindingsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get all bindings.
     * @param acceptLanguage language
     * @param {*} [options] Override http request options.
     */
    public getAll (acceptLanguage?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<BindingInfoDTO>;  }> {
        const localVarPath = this.basePath + '/bindings';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<BindingInfoDTO>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<BindingInfoDTO>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get binding configuration for given binding ID.
     * @param bindingId service ID
     * @param {*} [options] Override http request options.
     */
    public getConfiguration (bindingId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/bindings/{bindingId}/config'
            .replace('{' + 'bindingId' + '}', encodeURIComponent(String(bindingId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'bindingId' is not null or undefined
        if (bindingId === null || bindingId === undefined) {
            throw new Error('Required parameter bindingId was null or undefined when calling getConfiguration.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a binding configuration for given binding ID and returns the old configuration.
     * @param bindingId service ID
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public updateConfiguration (bindingId: string, body?: any, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/bindings/{bindingId}/config'
            .replace('{' + 'bindingId' + '}', encodeURIComponent(String(bindingId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'bindingId' is not null or undefined
        if (bindingId === null || bindingId === undefined) {
            throw new Error('Required parameter bindingId was null or undefined when calling updateConfiguration.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "any")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ChannelTypesApiApiKeys {
}

export class ChannelTypesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ChannelTypesApiApiKeys, value: string) {
        (this.authentications as any)[ChannelTypesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Gets all available channel types.
     * @param acceptLanguage Accept-Language
     * @param {*} [options] Override http request options.
     */
    public getAll (acceptLanguage?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<ChannelTypeDTO>;  }> {
        const localVarPath = this.basePath + '/channel-types';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ChannelTypeDTO>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ChannelTypeDTO>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets channel type by UID.
     * @param channelTypeUID channelTypeUID
     * @param acceptLanguage Accept-Language
     * @param {*} [options] Override http request options.
     */
    public getByUID (channelTypeUID: string, acceptLanguage?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ChannelTypeDTO;  }> {
        const localVarPath = this.basePath + '/channel-types/{channelTypeUID}'
            .replace('{' + 'channelTypeUID' + '}', encodeURIComponent(String(channelTypeUID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'channelTypeUID' is not null or undefined
        if (channelTypeUID === null || channelTypeUID === undefined) {
            throw new Error('Required parameter channelTypeUID was null or undefined when calling getByUID.');
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ChannelTypeDTO;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ChannelTypeDTO");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the item types the given trigger channel type UID can be linked to.
     * @param channelTypeUID channelTypeUID
     * @param {*} [options] Override http request options.
     */
    public getLinkableItemTypes (channelTypeUID: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/channel-types/{channelTypeUID}/linkableItemTypes'
            .replace('{' + 'channelTypeUID' + '}', encodeURIComponent(String(channelTypeUID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'channelTypeUID' is not null or undefined
        if (channelTypeUID === null || channelTypeUID === undefined) {
            throw new Error('Required parameter channelTypeUID was null or undefined when calling getLinkableItemTypes.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<string>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<string>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ConfigDescriptionsApiApiKeys {
}

export class ConfigDescriptionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ConfigDescriptionsApiApiKeys, value: string) {
        (this.authentications as any)[ConfigDescriptionsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Gets all available config descriptions.
     * @param acceptLanguage Accept-Language
     * @param scheme scheme filter
     * @param {*} [options] Override http request options.
     */
    public getAll (acceptLanguage?: string, scheme?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<ConfigDescriptionDTO>;  }> {
        const localVarPath = this.basePath + '/config-descriptions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (scheme !== undefined) {
            localVarQueryParameters['scheme'] = ObjectSerializer.serialize(scheme, "string");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ConfigDescriptionDTO>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ConfigDescriptionDTO>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets a config description by URI.
     * @param uri uri
     * @param acceptLanguage Accept-Language
     * @param {*} [options] Override http request options.
     */
    public getByURI (uri: string, acceptLanguage?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ConfigDescriptionDTO;  }> {
        const localVarPath = this.basePath + '/config-descriptions/{uri}'
            .replace('{' + 'uri' + '}', encodeURIComponent(String(uri)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'uri' is not null or undefined
        if (uri === null || uri === undefined) {
            throw new Error('Required parameter uri was null or undefined when calling getByURI.');
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ConfigDescriptionDTO;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ConfigDescriptionDTO");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DefaultApiApiKeys {
}

export class DefaultApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DefaultApiApiKeys, value: string) {
        (this.authentications as any)[DefaultApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @param acceptLanguage 
     * @param {*} [options] Override http request options.
     */
    public getAll (acceptLanguage?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/iconsets';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param {*} [options] Override http request options.
     */
    public getRoot (options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DiscoveryApiApiKeys {
}

export class DiscoveryApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DiscoveryApiApiKeys, value: string) {
        (this.authentications as any)[DiscoveryApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Gets all bindings that support discovery.
     * @param {*} [options] Override http request options.
     */
    public getDiscoveryServices (options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/discovery';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<string>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<string>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Starts asynchronous discovery process for a binding and returns the timeout in seconds of the discovery operation.
     * @param bindingId bindingId
     * @param {*} [options] Override http request options.
     */
    public scan (bindingId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: number;  }> {
        const localVarPath = this.basePath + '/discovery/bindings/{bindingId}/scan'
            .replace('{' + 'bindingId' + '}', encodeURIComponent(String(bindingId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'bindingId' is not null or undefined
        if (bindingId === null || bindingId === undefined) {
            throw new Error('Required parameter bindingId was null or undefined when calling scan.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: number;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "number");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ExtensionsApiApiKeys {
}

export class ExtensionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ExtensionsApiApiKeys, value: string) {
        (this.authentications as any)[ExtensionsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get extension with given ID.
     * @param extensionId extension ID
     * @param acceptLanguage language
     * @param {*} [options] Override http request options.
     */
    public getById (extensionId: string, acceptLanguage?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/extensions/{extensionId}'
            .replace('{' + 'extensionId' + '}', encodeURIComponent(String(extensionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'extensionId' is not null or undefined
        if (extensionId === null || extensionId === undefined) {
            throw new Error('Required parameter extensionId was null or undefined when calling getById.');
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all extensions.
     * @param acceptLanguage language
     * @param {*} [options] Override http request options.
     */
    public getExtensions (acceptLanguage?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/extensions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all extension types.
     * @param acceptLanguage language
     * @param {*} [options] Override http request options.
     */
    public getTypes (acceptLanguage?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/extensions/types';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Installs the extension with the given ID.
     * @param extensionId extension ID
     * @param {*} [options] Override http request options.
     */
    public installExtension (extensionId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/extensions/{extensionId}/install'
            .replace('{' + 'extensionId' + '}', encodeURIComponent(String(extensionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'extensionId' is not null or undefined
        if (extensionId === null || extensionId === undefined) {
            throw new Error('Required parameter extensionId was null or undefined when calling installExtension.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Installs the extension from the given URL.
     * @param url extension install URL
     * @param {*} [options] Override http request options.
     */
    public installExtensionByURL (url: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/extensions/url/{url}/install'
            .replace('{' + 'url' + '}', encodeURIComponent(String(url)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'url' is not null or undefined
        if (url === null || url === undefined) {
            throw new Error('Required parameter url was null or undefined when calling installExtensionByURL.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @param extensionId extension ID
     * @param {*} [options] Override http request options.
     */
    public uninstallExtension (extensionId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/extensions/{extensionId}/uninstall'
            .replace('{' + 'extensionId' + '}', encodeURIComponent(String(extensionId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'extensionId' is not null or undefined
        if (extensionId === null || extensionId === undefined) {
            throw new Error('Required parameter extensionId was null or undefined when calling uninstallExtension.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum HabpanelApiApiKeys {
}

export class HabpanelApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: HabpanelApiApiKeys, value: string) {
        (this.authentications as any)[HabpanelApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Gets the list of widget gallery items.
     * @param galleryName gallery name e.g. &#39;community&#39;
     * @param {*} [options] Override http request options.
     */
    public getGalleryWidgetList (galleryName: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/habpanel/gallery/{galleryName}/widgets'
            .replace('{' + 'galleryName' + '}', encodeURIComponent(String(galleryName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'galleryName' is not null or undefined
        if (galleryName === null || galleryName === undefined) {
            throw new Error('Required parameter galleryName was null or undefined when calling getGalleryWidgetList.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the details about a widget gallery item.
     * @param galleryName gallery name e.g. &#39;community&#39;
     * @param id id within the gallery
     * @param {*} [options] Override http request options.
     */
    public getGalleryWidgetsItem (galleryName: string, id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/habpanel/gallery/{galleryName}/widgets/{id}'
            .replace('{' + 'galleryName' + '}', encodeURIComponent(String(galleryName)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'galleryName' is not null or undefined
        if (galleryName === null || galleryName === undefined) {
            throw new Error('Required parameter galleryName was null or undefined when calling getGalleryWidgetsItem.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getGalleryWidgetsItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum InboxApiApiKeys {
}

export class InboxApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: InboxApiApiKeys, value: string) {
        (this.authentications as any)[InboxApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Removes the discovery result from the inbox.
     * @param thingUID thingUID
     * @param {*} [options] Override http request options.
     */
    public _delete (thingUID: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/inbox/{thingUID}'
            .replace('{' + 'thingUID' + '}', encodeURIComponent(String(thingUID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'thingUID' is not null or undefined
        if (thingUID === null || thingUID === undefined) {
            throw new Error('Required parameter thingUID was null or undefined when calling _delete.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Approves the discovery result by adding the thing to the registry.
     * @param thingUID thingUID
     * @param acceptLanguage language
     * @param body thing label
     * @param {*} [options] Override http request options.
     */
    public approve (thingUID: string, acceptLanguage?: string, body?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/inbox/{thingUID}/approve'
            .replace('{' + 'thingUID' + '}', encodeURIComponent(String(thingUID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'thingUID' is not null or undefined
        if (thingUID === null || thingUID === undefined) {
            throw new Error('Required parameter thingUID was null or undefined when calling approve.');
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "string")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all discovered things.
     * @param {*} [options] Override http request options.
     */
    public getAll (options: any = {}) : Promise<{ response: http.IncomingMessage; body: DiscoveryResultDTO;  }> {
        const localVarPath = this.basePath + '/inbox';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: DiscoveryResultDTO;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "DiscoveryResultDTO");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Flags a discovery result as ignored for further processing.
     * @param thingUID thingUID
     * @param {*} [options] Override http request options.
     */
    public ignore (thingUID: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/inbox/{thingUID}/ignore'
            .replace('{' + 'thingUID' + '}', encodeURIComponent(String(thingUID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'thingUID' is not null or undefined
        if (thingUID === null || thingUID === undefined) {
            throw new Error('Required parameter thingUID was null or undefined when calling ignore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Removes ignore flag from a discovery result.
     * @param thingUID thingUID
     * @param {*} [options] Override http request options.
     */
    public unignore (thingUID: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/inbox/{thingUID}/unignore'
            .replace('{' + 'thingUID' + '}', encodeURIComponent(String(thingUID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'thingUID' is not null or undefined
        if (thingUID === null || thingUID === undefined) {
            throw new Error('Required parameter thingUID was null or undefined when calling unignore.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ItemsApiApiKeys {
}

export class ItemsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ItemsApiApiKeys, value: string) {
        (this.authentications as any)[ItemsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Adds a new member to a group item.
     * @param itemName item name
     * @param memberItemName member item name
     * @param {*} [options] Override http request options.
     */
    public addMember (itemName: string, memberItemName: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/items/{itemName}/members/{memberItemName}'
            .replace('{' + 'itemName' + '}', encodeURIComponent(String(itemName)))
            .replace('{' + 'memberItemName' + '}', encodeURIComponent(String(memberItemName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'itemName' is not null or undefined
        if (itemName === null || itemName === undefined) {
            throw new Error('Required parameter itemName was null or undefined when calling addMember.');
        }

        // verify required parameter 'memberItemName' is not null or undefined
        if (memberItemName === null || memberItemName === undefined) {
            throw new Error('Required parameter memberItemName was null or undefined when calling addMember.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds metadata to an item.
     * @param itemname item name
     * @param namespace namespace
     * @param body metadata
     * @param {*} [options] Override http request options.
     */
    public addMetadata (itemname: string, namespace: string, body: MetadataDTO, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/items/{itemname}/metadata/{namespace}'
            .replace('{' + 'itemname' + '}', encodeURIComponent(String(itemname)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'itemname' is not null or undefined
        if (itemname === null || itemname === undefined) {
            throw new Error('Required parameter itemname was null or undefined when calling addMetadata.');
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling addMetadata.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling addMetadata.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "MetadataDTO")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a tag to an item.
     * @param itemname item name
     * @param tag tag
     * @param {*} [options] Override http request options.
     */
    public addTag (itemname: string, tag: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/items/{itemname}/tags/{tag}'
            .replace('{' + 'itemname' + '}', encodeURIComponent(String(itemname)))
            .replace('{' + 'tag' + '}', encodeURIComponent(String(tag)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'itemname' is not null or undefined
        if (itemname === null || itemname === undefined) {
            throw new Error('Required parameter itemname was null or undefined when calling addTag.');
        }

        // verify required parameter 'tag' is not null or undefined
        if (tag === null || tag === undefined) {
            throw new Error('Required parameter tag was null or undefined when calling addTag.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a new item to the registry or updates the existing item.
     * @param itemname item name
     * @param body item data
     * @param acceptLanguage language
     * @param {*} [options] Override http request options.
     */
    public createOrUpdateItem (itemname: string, body: GroupItemDTO, acceptLanguage?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/items/{itemname}'
            .replace('{' + 'itemname' + '}', encodeURIComponent(String(itemname)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'itemname' is not null or undefined
        if (itemname === null || itemname === undefined) {
            throw new Error('Required parameter itemname was null or undefined when calling createOrUpdateItem.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createOrUpdateItem.');
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "GroupItemDTO")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Adds a list of items to the registry or updates the existing items.
     * @param body array of item data
     * @param {*} [options] Override http request options.
     */
    public createOrUpdateItems (body: Array<GroupItemDTO>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/items';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createOrUpdateItems.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "Array<GroupItemDTO>")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets a single item.
     * @param itemname item name
     * @param acceptLanguage language
     * @param metadata metadata selector
     * @param {*} [options] Override http request options.
     */
    public getItemData (itemname: string, acceptLanguage?: string, metadata?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: EnrichedItemDTO;  }> {
        const localVarPath = this.basePath + '/items/{itemname}'
            .replace('{' + 'itemname' + '}', encodeURIComponent(String(itemname)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'itemname' is not null or undefined
        if (itemname === null || itemname === undefined) {
            throw new Error('Required parameter itemname was null or undefined when calling getItemData.');
        }

        if (metadata !== undefined) {
            localVarQueryParameters['metadata'] = ObjectSerializer.serialize(metadata, "string");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: EnrichedItemDTO;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EnrichedItemDTO");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all available items.
     * @param acceptLanguage language
     * @param type item type filter
     * @param tags item tag filter
     * @param metadata metadata selector
     * @param recursive get member items recursively
     * @param fields limit output to the given fields (comma separated)
     * @param {*} [options] Override http request options.
     */
    public getItems (acceptLanguage?: string, type?: string, tags?: string, metadata?: string, recursive?: boolean, fields?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<EnrichedItemDTO>;  }> {
        const localVarPath = this.basePath + '/items';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "string");
        }

        if (tags !== undefined) {
            localVarQueryParameters['tags'] = ObjectSerializer.serialize(tags, "string");
        }

        if (metadata !== undefined) {
            localVarQueryParameters['metadata'] = ObjectSerializer.serialize(metadata, "string");
        }

        if (recursive !== undefined) {
            localVarQueryParameters['recursive'] = ObjectSerializer.serialize(recursive, "boolean");
        }

        if (fields !== undefined) {
            localVarQueryParameters['fields'] = ObjectSerializer.serialize(fields, "string");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<EnrichedItemDTO>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<EnrichedItemDTO>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the state of an item.
     * @param itemname item name
     * @param {*} [options] Override http request options.
     */
    public getPlainItemState (itemname: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/items/{itemname}/state'
            .replace('{' + 'itemname' + '}', encodeURIComponent(String(itemname)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'itemname' is not null or undefined
        if (itemname === null || itemname === undefined) {
            throw new Error('Required parameter itemname was null or undefined when calling getPlainItemState.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Sends a command to an item.
     * @param itemname item name
     * @param body valid item command (e.g. ON, OFF, UP, DOWN, REFRESH)
     * @param {*} [options] Override http request options.
     */
    public postItemCommand (itemname: string, body: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/items/{itemname}'
            .replace('{' + 'itemname' + '}', encodeURIComponent(String(itemname)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'itemname' is not null or undefined
        if (itemname === null || itemname === undefined) {
            throw new Error('Required parameter itemname was null or undefined when calling postItemCommand.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postItemCommand.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "string")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates the state of an item.
     * @param itemname item name
     * @param body valid item state (e.g. ON, OFF)
     * @param acceptLanguage language
     * @param {*} [options] Override http request options.
     */
    public putItemState (itemname: string, body: string, acceptLanguage?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/items/{itemname}/state'
            .replace('{' + 'itemname' + '}', encodeURIComponent(String(itemname)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'itemname' is not null or undefined
        if (itemname === null || itemname === undefined) {
            throw new Error('Required parameter itemname was null or undefined when calling putItemState.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling putItemState.');
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "string")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Removes an item from the registry.
     * @param itemname item name
     * @param {*} [options] Override http request options.
     */
    public removeItem (itemname: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/items/{itemname}'
            .replace('{' + 'itemname' + '}', encodeURIComponent(String(itemname)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'itemname' is not null or undefined
        if (itemname === null || itemname === undefined) {
            throw new Error('Required parameter itemname was null or undefined when calling removeItem.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Removes an existing member from a group item.
     * @param itemName item name
     * @param memberItemName member item name
     * @param {*} [options] Override http request options.
     */
    public removeMember (itemName: string, memberItemName: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/items/{itemName}/members/{memberItemName}'
            .replace('{' + 'itemName' + '}', encodeURIComponent(String(itemName)))
            .replace('{' + 'memberItemName' + '}', encodeURIComponent(String(memberItemName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'itemName' is not null or undefined
        if (itemName === null || itemName === undefined) {
            throw new Error('Required parameter itemName was null or undefined when calling removeMember.');
        }

        // verify required parameter 'memberItemName' is not null or undefined
        if (memberItemName === null || memberItemName === undefined) {
            throw new Error('Required parameter memberItemName was null or undefined when calling removeMember.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Removes metadata from an item.
     * @param itemname item name
     * @param namespace namespace
     * @param {*} [options] Override http request options.
     */
    public removeMetadata (itemname: string, namespace: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/items/{itemname}/metadata/{namespace}'
            .replace('{' + 'itemname' + '}', encodeURIComponent(String(itemname)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'itemname' is not null or undefined
        if (itemname === null || itemname === undefined) {
            throw new Error('Required parameter itemname was null or undefined when calling removeMetadata.');
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error('Required parameter namespace was null or undefined when calling removeMetadata.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Removes a tag from an item.
     * @param itemname item name
     * @param tag tag
     * @param {*} [options] Override http request options.
     */
    public removeTag (itemname: string, tag: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/items/{itemname}/tags/{tag}'
            .replace('{' + 'itemname' + '}', encodeURIComponent(String(itemname)))
            .replace('{' + 'tag' + '}', encodeURIComponent(String(tag)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'itemname' is not null or undefined
        if (itemname === null || itemname === undefined) {
            throw new Error('Required parameter itemname was null or undefined when calling removeTag.');
        }

        // verify required parameter 'tag' is not null or undefined
        if (tag === null || tag === undefined) {
            throw new Error('Required parameter tag was null or undefined when calling removeTag.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LinksApiApiKeys {
}

export class LinksApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LinksApiApiKeys, value: string) {
        (this.authentications as any)[LinksApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Gets all available links.
     * @param {*} [options] Override http request options.
     */
    public getAll (options: any = {}) : Promise<{ response: http.IncomingMessage; body: ItemChannelLinkDTO;  }> {
        const localVarPath = this.basePath + '/links';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemChannelLinkDTO;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemChannelLinkDTO");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves links.
     * @param itemName itemName
     * @param channelUID channelUID
     * @param {*} [options] Override http request options.
     */
    public getLink (itemName: string, channelUID: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/links/{itemName}/{channelUID}'
            .replace('{' + 'itemName' + '}', encodeURIComponent(String(itemName)))
            .replace('{' + 'channelUID' + '}', encodeURIComponent(String(channelUID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'itemName' is not null or undefined
        if (itemName === null || itemName === undefined) {
            throw new Error('Required parameter itemName was null or undefined when calling getLink.');
        }

        // verify required parameter 'channelUID' is not null or undefined
        if (channelUID === null || channelUID === undefined) {
            throw new Error('Required parameter channelUID was null or undefined when calling getLink.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Tells whether automatic link mode is active or not
     * @param {*} [options] Override http request options.
     */
    public isAutomatic (options: any = {}) : Promise<{ response: http.IncomingMessage; body: boolean;  }> {
        const localVarPath = this.basePath + '/links/auto';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: boolean;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "boolean");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Links item to a channel.
     * @param itemName itemName
     * @param channelUID channelUID
     * @param body link data
     * @param {*} [options] Override http request options.
     */
    public link (itemName: string, channelUID: string, body?: ItemChannelLinkDTO, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/links/{itemName}/{channelUID}'
            .replace('{' + 'itemName' + '}', encodeURIComponent(String(itemName)))
            .replace('{' + 'channelUID' + '}', encodeURIComponent(String(channelUID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'itemName' is not null or undefined
        if (itemName === null || itemName === undefined) {
            throw new Error('Required parameter itemName was null or undefined when calling link.');
        }

        // verify required parameter 'channelUID' is not null or undefined
        if (channelUID === null || channelUID === undefined) {
            throw new Error('Required parameter channelUID was null or undefined when calling link.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ItemChannelLinkDTO")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Unlinks item from a channel.
     * @param itemName itemName
     * @param channelUID channelUID
     * @param {*} [options] Override http request options.
     */
    public unlink (itemName: string, channelUID: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/links/{itemName}/{channelUID}'
            .replace('{' + 'itemName' + '}', encodeURIComponent(String(itemName)))
            .replace('{' + 'channelUID' + '}', encodeURIComponent(String(channelUID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'itemName' is not null or undefined
        if (itemName === null || itemName === undefined) {
            throw new Error('Required parameter itemName was null or undefined when calling unlink.');
        }

        // verify required parameter 'channelUID' is not null or undefined
        if (channelUID === null || channelUID === undefined) {
            throw new Error('Required parameter channelUID was null or undefined when calling unlink.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ModuleTypesApiApiKeys {
}

export class ModuleTypesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ModuleTypesApiApiKeys, value: string) {
        (this.authentications as any)[ModuleTypesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get all available module types.
     * @param acceptLanguage language
     * @param tags tags for filtering
     * @param type filtering by action, condition or trigger
     * @param {*} [options] Override http request options.
     */
    public getAll (acceptLanguage?: string, tags?: string, type?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<ModuleTypeDTO>;  }> {
        const localVarPath = this.basePath + '/module-types';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (tags !== undefined) {
            localVarQueryParameters['tags'] = ObjectSerializer.serialize(tags, "string");
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "string");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ModuleTypeDTO>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ModuleTypeDTO>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets a module type corresponding to the given UID.
     * @param moduleTypeUID moduleTypeUID
     * @param acceptLanguage language
     * @param {*} [options] Override http request options.
     */
    public getByUID (moduleTypeUID: string, acceptLanguage?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ModuleTypeDTO;  }> {
        const localVarPath = this.basePath + '/module-types/{moduleTypeUID}'
            .replace('{' + 'moduleTypeUID' + '}', encodeURIComponent(String(moduleTypeUID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'moduleTypeUID' is not null or undefined
        if (moduleTypeUID === null || moduleTypeUID === undefined) {
            throw new Error('Required parameter moduleTypeUID was null or undefined when calling getByUID.');
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ModuleTypeDTO;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ModuleTypeDTO");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PersistenceApiApiKeys {
}

export class PersistenceApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PersistenceApiApiKeys, value: string) {
        (this.authentications as any)[PersistenceApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Delete item data from a specific persistence service.
     * @param serviceId Id of the persistence service.
     * @param itemname The item name.
     * @param starttime Start time of the data to return. [yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ]
     * @param endtime End time of the data to return. [yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ]
     * @param {*} [options] Override http request options.
     */
    public httpDeletePersistenceServiceItem (serviceId: string, itemname: string, starttime: string, endtime: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/persistence/items/{itemname}'
            .replace('{' + 'itemname' + '}', encodeURIComponent(String(itemname)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'serviceId' is not null or undefined
        if (serviceId === null || serviceId === undefined) {
            throw new Error('Required parameter serviceId was null or undefined when calling httpDeletePersistenceServiceItem.');
        }

        // verify required parameter 'itemname' is not null or undefined
        if (itemname === null || itemname === undefined) {
            throw new Error('Required parameter itemname was null or undefined when calling httpDeletePersistenceServiceItem.');
        }

        // verify required parameter 'starttime' is not null or undefined
        if (starttime === null || starttime === undefined) {
            throw new Error('Required parameter starttime was null or undefined when calling httpDeletePersistenceServiceItem.');
        }

        // verify required parameter 'endtime' is not null or undefined
        if (endtime === null || endtime === undefined) {
            throw new Error('Required parameter endtime was null or undefined when calling httpDeletePersistenceServiceItem.');
        }

        if (serviceId !== undefined) {
            localVarQueryParameters['serviceId'] = ObjectSerializer.serialize(serviceId, "string");
        }

        if (starttime !== undefined) {
            localVarQueryParameters['starttime'] = ObjectSerializer.serialize(starttime, "string");
        }

        if (endtime !== undefined) {
            localVarQueryParameters['endtime'] = ObjectSerializer.serialize(endtime, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<string>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<string>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets item persistence data from the persistence service.
     * @param itemname The item name
     * @param serviceId Id of the persistence service. If not provided the default service will be used
     * @param starttime Start time of the data to return. Will default to 1 day before endtime. [yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ]
     * @param endtime End time of the data to return. Will default to current time. [yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ]
     * @param page Page number of data to return. This parameter will enable paging.
     * @param pagelength The length of each page.
     * @param boundary Gets one value before and after the requested period.
     * @param {*} [options] Override http request options.
     */
    public httpGetPersistenceItemData (itemname: string, serviceId?: string, starttime?: string, endtime?: string, page?: number, pagelength?: number, boundary?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ItemHistoryDTO;  }> {
        const localVarPath = this.basePath + '/persistence/items/{itemname}'
            .replace('{' + 'itemname' + '}', encodeURIComponent(String(itemname)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'itemname' is not null or undefined
        if (itemname === null || itemname === undefined) {
            throw new Error('Required parameter itemname was null or undefined when calling httpGetPersistenceItemData.');
        }

        if (serviceId !== undefined) {
            localVarQueryParameters['serviceId'] = ObjectSerializer.serialize(serviceId, "string");
        }

        if (starttime !== undefined) {
            localVarQueryParameters['starttime'] = ObjectSerializer.serialize(starttime, "string");
        }

        if (endtime !== undefined) {
            localVarQueryParameters['endtime'] = ObjectSerializer.serialize(endtime, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (pagelength !== undefined) {
            localVarQueryParameters['pagelength'] = ObjectSerializer.serialize(pagelength, "number");
        }

        if (boundary !== undefined) {
            localVarQueryParameters['boundary'] = ObjectSerializer.serialize(boundary, "boolean");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemHistoryDTO;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemHistoryDTO");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets a list of items available via a specific persistence service.
     * @param serviceId Id of the persistence service. If not provided the default service will be used
     * @param {*} [options] Override http request options.
     */
    public httpGetPersistenceServiceItems (serviceId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/persistence/items';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (serviceId !== undefined) {
            localVarQueryParameters['serviceId'] = ObjectSerializer.serialize(serviceId, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<string>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<string>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets a list of persistence services.
     * @param acceptLanguage Accept-Language
     * @param {*} [options] Override http request options.
     */
    public httpGetPersistenceServices (acceptLanguage?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<string>;  }> {
        const localVarPath = this.basePath + '/persistence';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<string>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<string>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Stores item persistence data into the persistence service.
     * @param itemname The item name.
     * @param time Time of the data to be stored. Will default to current time. [yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSSZ]
     * @param state The state to store.
     * @param serviceId Id of the persistence service. If not provided the default service will be used
     * @param {*} [options] Override http request options.
     */
    public httpPutPersistenceItemData (itemname: string, time: string, state: string, serviceId?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ItemHistoryDTO;  }> {
        const localVarPath = this.basePath + '/persistence/items/{itemname}'
            .replace('{' + 'itemname' + '}', encodeURIComponent(String(itemname)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'itemname' is not null or undefined
        if (itemname === null || itemname === undefined) {
            throw new Error('Required parameter itemname was null or undefined when calling httpPutPersistenceItemData.');
        }

        // verify required parameter 'time' is not null or undefined
        if (time === null || time === undefined) {
            throw new Error('Required parameter time was null or undefined when calling httpPutPersistenceItemData.');
        }

        // verify required parameter 'state' is not null or undefined
        if (state === null || state === undefined) {
            throw new Error('Required parameter state was null or undefined when calling httpPutPersistenceItemData.');
        }

        if (serviceId !== undefined) {
            localVarQueryParameters['serviceId'] = ObjectSerializer.serialize(serviceId, "string");
        }

        if (time !== undefined) {
            localVarQueryParameters['time'] = ObjectSerializer.serialize(time, "string");
        }

        if (state !== undefined) {
            localVarQueryParameters['state'] = ObjectSerializer.serialize(state, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ItemHistoryDTO;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ItemHistoryDTO");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ProfileTypesApiApiKeys {
}

export class ProfileTypesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ProfileTypesApiApiKeys, value: string) {
        (this.authentications as any)[ProfileTypesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Gets all available profile types.
     * @param acceptLanguage Accept-Language
     * @param channelTypeUID channel type filter
     * @param itemType item type filter
     * @param {*} [options] Override http request options.
     */
    public getAll (acceptLanguage?: string, channelTypeUID?: string, itemType?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<ProfileTypeDTO>;  }> {
        const localVarPath = this.basePath + '/profile-types';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (channelTypeUID !== undefined) {
            localVarQueryParameters['channelTypeUID'] = ObjectSerializer.serialize(channelTypeUID, "string");
        }

        if (itemType !== undefined) {
            localVarQueryParameters['itemType'] = ObjectSerializer.serialize(itemType, "string");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ProfileTypeDTO>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ProfileTypeDTO>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RulesApiApiKeys {
}

export class RulesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: RulesApiApiKeys, value: string) {
        (this.authentications as any)[RulesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Creates a rule.
     * @param body rule data
     * @param {*} [options] Override http request options.
     */
    public create (body: RuleDTO, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/rules';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "RuleDTO")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Sets the rule enabled status.
     * @param ruleUID ruleUID
     * @param body enable
     * @param {*} [options] Override http request options.
     */
    public enableRule (ruleUID: string, body: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/rules/{ruleUID}/enable'
            .replace('{' + 'ruleUID' + '}', encodeURIComponent(String(ruleUID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'ruleUID' is not null or undefined
        if (ruleUID === null || ruleUID === undefined) {
            throw new Error('Required parameter ruleUID was null or undefined when calling enableRule.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling enableRule.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "string")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get available rules, optionally filtered by tags and/or prefix.
     * @param prefix 
     * @param tags 
     * @param {*} [options] Override http request options.
     */
    public get (prefix?: string, tags?: Array<string>, options: any = {}) : Promise<{ response: http.IncomingMessage; body: EnrichedRuleDTO;  }> {
        const localVarPath = this.basePath + '/rules';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        if (prefix !== undefined) {
            localVarQueryParameters['prefix'] = ObjectSerializer.serialize(prefix, "string");
        }

        if (tags !== undefined) {
            localVarQueryParameters['tags'] = ObjectSerializer.serialize(tags, "Array<string>");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: EnrichedRuleDTO;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EnrichedRuleDTO");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the rule actions.
     * @param ruleUID ruleUID
     * @param {*} [options] Override http request options.
     */
    public getActions (ruleUID: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<ActionDTO>;  }> {
        const localVarPath = this.basePath + '/rules/{ruleUID}/actions'
            .replace('{' + 'ruleUID' + '}', encodeURIComponent(String(ruleUID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'ruleUID' is not null or undefined
        if (ruleUID === null || ruleUID === undefined) {
            throw new Error('Required parameter ruleUID was null or undefined when calling getActions.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ActionDTO>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ActionDTO>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the rule corresponding to the given UID.
     * @param ruleUID ruleUID
     * @param {*} [options] Override http request options.
     */
    public getByUID (ruleUID: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: EnrichedRuleDTO;  }> {
        const localVarPath = this.basePath + '/rules/{ruleUID}'
            .replace('{' + 'ruleUID' + '}', encodeURIComponent(String(ruleUID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'ruleUID' is not null or undefined
        if (ruleUID === null || ruleUID === undefined) {
            throw new Error('Required parameter ruleUID was null or undefined when calling getByUID.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: EnrichedRuleDTO;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "EnrichedRuleDTO");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the rule conditions.
     * @param ruleUID ruleUID
     * @param {*} [options] Override http request options.
     */
    public getConditions (ruleUID: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<ConditionDTO>;  }> {
        const localVarPath = this.basePath + '/rules/{ruleUID}/conditions'
            .replace('{' + 'ruleUID' + '}', encodeURIComponent(String(ruleUID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'ruleUID' is not null or undefined
        if (ruleUID === null || ruleUID === undefined) {
            throw new Error('Required parameter ruleUID was null or undefined when calling getConditions.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ConditionDTO>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ConditionDTO>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the rule configuration values.
     * @param ruleUID ruleUID
     * @param {*} [options] Override http request options.
     */
    public getConfiguration (ruleUID: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/rules/{ruleUID}/config'
            .replace('{' + 'ruleUID' + '}', encodeURIComponent(String(ruleUID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'ruleUID' is not null or undefined
        if (ruleUID === null || ruleUID === undefined) {
            throw new Error('Required parameter ruleUID was null or undefined when calling getConfiguration.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the rule's module corresponding to the given Category and ID.
     * @param ruleUID ruleUID
     * @param moduleCategory moduleCategory
     * @param id id
     * @param {*} [options] Override http request options.
     */
    public getModuleById (ruleUID: string, moduleCategory: string, id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ModuleDTO;  }> {
        const localVarPath = this.basePath + '/rules/{ruleUID}/{moduleCategory}/{id}'
            .replace('{' + 'ruleUID' + '}', encodeURIComponent(String(ruleUID)))
            .replace('{' + 'moduleCategory' + '}', encodeURIComponent(String(moduleCategory)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'ruleUID' is not null or undefined
        if (ruleUID === null || ruleUID === undefined) {
            throw new Error('Required parameter ruleUID was null or undefined when calling getModuleById.');
        }

        // verify required parameter 'moduleCategory' is not null or undefined
        if (moduleCategory === null || moduleCategory === undefined) {
            throw new Error('Required parameter moduleCategory was null or undefined when calling getModuleById.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getModuleById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ModuleDTO;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ModuleDTO");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the module's configuration.
     * @param ruleUID ruleUID
     * @param moduleCategory moduleCategory
     * @param id id
     * @param {*} [options] Override http request options.
     */
    public getModuleConfig (ruleUID: string, moduleCategory: string, id: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/rules/{ruleUID}/{moduleCategory}/{id}/config'
            .replace('{' + 'ruleUID' + '}', encodeURIComponent(String(ruleUID)))
            .replace('{' + 'moduleCategory' + '}', encodeURIComponent(String(moduleCategory)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'ruleUID' is not null or undefined
        if (ruleUID === null || ruleUID === undefined) {
            throw new Error('Required parameter ruleUID was null or undefined when calling getModuleConfig.');
        }

        // verify required parameter 'moduleCategory' is not null or undefined
        if (moduleCategory === null || moduleCategory === undefined) {
            throw new Error('Required parameter moduleCategory was null or undefined when calling getModuleConfig.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getModuleConfig.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the module's configuration parameter.
     * @param ruleUID ruleUID
     * @param moduleCategory moduleCategory
     * @param id id
     * @param param param
     * @param {*} [options] Override http request options.
     */
    public getModuleConfigParam (ruleUID: string, moduleCategory: string, id: string, param: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/rules/{ruleUID}/{moduleCategory}/{id}/config/{param}'
            .replace('{' + 'ruleUID' + '}', encodeURIComponent(String(ruleUID)))
            .replace('{' + 'moduleCategory' + '}', encodeURIComponent(String(moduleCategory)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'param' + '}', encodeURIComponent(String(param)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'ruleUID' is not null or undefined
        if (ruleUID === null || ruleUID === undefined) {
            throw new Error('Required parameter ruleUID was null or undefined when calling getModuleConfigParam.');
        }

        // verify required parameter 'moduleCategory' is not null or undefined
        if (moduleCategory === null || moduleCategory === undefined) {
            throw new Error('Required parameter moduleCategory was null or undefined when calling getModuleConfigParam.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getModuleConfigParam.');
        }

        // verify required parameter 'param' is not null or undefined
        if (param === null || param === undefined) {
            throw new Error('Required parameter param was null or undefined when calling getModuleConfigParam.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets the rule triggers.
     * @param ruleUID ruleUID
     * @param {*} [options] Override http request options.
     */
    public getTriggers (ruleUID: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<TriggerDTO>;  }> {
        const localVarPath = this.basePath + '/rules/{ruleUID}/triggers'
            .replace('{' + 'ruleUID' + '}', encodeURIComponent(String(ruleUID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'ruleUID' is not null or undefined
        if (ruleUID === null || ruleUID === undefined) {
            throw new Error('Required parameter ruleUID was null or undefined when calling getTriggers.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<TriggerDTO>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<TriggerDTO>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Removes an existing rule corresponding to the given UID.
     * @param ruleUID ruleUID
     * @param {*} [options] Override http request options.
     */
    public remove (ruleUID: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/rules/{ruleUID}'
            .replace('{' + 'ruleUID' + '}', encodeURIComponent(String(ruleUID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'ruleUID' is not null or undefined
        if (ruleUID === null || ruleUID === undefined) {
            throw new Error('Required parameter ruleUID was null or undefined when calling remove.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Executes actions of the rule.
     * @param ruleUID ruleUID
     * @param {*} [options] Override http request options.
     */
    public runNow (ruleUID: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/rules/{ruleUID}/runnow'
            .replace('{' + 'ruleUID' + '}', encodeURIComponent(String(ruleUID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'ruleUID' is not null or undefined
        if (ruleUID === null || ruleUID === undefined) {
            throw new Error('Required parameter ruleUID was null or undefined when calling runNow.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Sets the module's configuration parameter value.
     * @param ruleUID ruleUID
     * @param moduleCategory moduleCategory
     * @param id id
     * @param param param
     * @param body value
     * @param {*} [options] Override http request options.
     */
    public setModuleConfigParam (ruleUID: string, moduleCategory: string, id: string, param: string, body: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/rules/{ruleUID}/{moduleCategory}/{id}/config/{param}'
            .replace('{' + 'ruleUID' + '}', encodeURIComponent(String(ruleUID)))
            .replace('{' + 'moduleCategory' + '}', encodeURIComponent(String(moduleCategory)))
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)))
            .replace('{' + 'param' + '}', encodeURIComponent(String(param)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'ruleUID' is not null or undefined
        if (ruleUID === null || ruleUID === undefined) {
            throw new Error('Required parameter ruleUID was null or undefined when calling setModuleConfigParam.');
        }

        // verify required parameter 'moduleCategory' is not null or undefined
        if (moduleCategory === null || moduleCategory === undefined) {
            throw new Error('Required parameter moduleCategory was null or undefined when calling setModuleConfigParam.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling setModuleConfigParam.');
        }

        // verify required parameter 'param' is not null or undefined
        if (param === null || param === undefined) {
            throw new Error('Required parameter param was null or undefined when calling setModuleConfigParam.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling setModuleConfigParam.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "string")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates an existing rule corresponding to the given UID.
     * @param ruleUID ruleUID
     * @param body rule data
     * @param {*} [options] Override http request options.
     */
    public update (ruleUID: string, body: RuleDTO, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/rules/{ruleUID}'
            .replace('{' + 'ruleUID' + '}', encodeURIComponent(String(ruleUID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'ruleUID' is not null or undefined
        if (ruleUID === null || ruleUID === undefined) {
            throw new Error('Required parameter ruleUID was null or undefined when calling update.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "RuleDTO")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Sets the rule configuration values.
     * @param ruleUID ruleUID
     * @param body config
     * @param {*} [options] Override http request options.
     */
    public updateConfiguration (ruleUID: string, body?: any, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/rules/{ruleUID}/config'
            .replace('{' + 'ruleUID' + '}', encodeURIComponent(String(ruleUID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'ruleUID' is not null or undefined
        if (ruleUID === null || ruleUID === undefined) {
            throw new Error('Required parameter ruleUID was null or undefined when calling updateConfiguration.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "any")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ServicesApiApiKeys {
}

export class ServicesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ServicesApiApiKeys, value: string) {
        (this.authentications as any)[ServicesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Deletes a service configuration for given service ID and returns the old configuration.
     * @param serviceId service ID
     * @param {*} [options] Override http request options.
     */
    public deleteConfiguration (serviceId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/services/{serviceId}/config'
            .replace('{' + 'serviceId' + '}', encodeURIComponent(String(serviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'serviceId' is not null or undefined
        if (serviceId === null || serviceId === undefined) {
            throw new Error('Required parameter serviceId was null or undefined when calling deleteConfiguration.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all configurable services.
     * @param {*} [options] Override http request options.
     */
    public getAll (options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<ConfigurableServiceDTO>;  }> {
        const localVarPath = this.basePath + '/services';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ConfigurableServiceDTO>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ConfigurableServiceDTO>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get configurable service for given service ID.
     * @param serviceId service ID
     * @param {*} [options] Override http request options.
     */
    public getById (serviceId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ConfigurableServiceDTO;  }> {
        const localVarPath = this.basePath + '/services/{serviceId}'
            .replace('{' + 'serviceId' + '}', encodeURIComponent(String(serviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'serviceId' is not null or undefined
        if (serviceId === null || serviceId === undefined) {
            throw new Error('Required parameter serviceId was null or undefined when calling getById.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ConfigurableServiceDTO;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ConfigurableServiceDTO");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get service configuration for given service ID.
     * @param serviceId service ID
     * @param {*} [options] Override http request options.
     */
    public getConfiguration (serviceId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/services/{serviceId}/config'
            .replace('{' + 'serviceId' + '}', encodeURIComponent(String(serviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'serviceId' is not null or undefined
        if (serviceId === null || serviceId === undefined) {
            throw new Error('Required parameter serviceId was null or undefined when calling getConfiguration.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get existing multiple context service configurations for the given factory PID.
     * @param serviceId service ID
     * @param {*} [options] Override http request options.
     */
    public getMultiConfigServicesByFactoryPid (serviceId: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<ConfigurableServiceDTO>;  }> {
        const localVarPath = this.basePath + '/services/{serviceId}/contexts'
            .replace('{' + 'serviceId' + '}', encodeURIComponent(String(serviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'serviceId' is not null or undefined
        if (serviceId === null || serviceId === undefined) {
            throw new Error('Required parameter serviceId was null or undefined when calling getMultiConfigServicesByFactoryPid.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<ConfigurableServiceDTO>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<ConfigurableServiceDTO>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a service configuration for given service ID and returns the old configuration.
     * @param serviceId service ID
     * @param body 
     * @param {*} [options] Override http request options.
     */
    public updateConfiguration (serviceId: string, body?: any, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/services/{serviceId}/config'
            .replace('{' + 'serviceId' + '}', encodeURIComponent(String(serviceId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'serviceId' is not null or undefined
        if (serviceId === null || serviceId === undefined) {
            throw new Error('Required parameter serviceId was null or undefined when calling updateConfiguration.');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "any")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum SitemapsApiApiKeys {
}

export class SitemapsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: SitemapsApiApiKeys, value: string) {
        (this.authentications as any)[SitemapsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Creates a sitemap event subscription.
     * @param {*} [options] Override http request options.
     */
    public createEventSubscription (options: any = {}) : Promise<{ response: http.IncomingMessage; body: any;  }> {
        const localVarPath = this.basePath + '/sitemaps/events/subscribe';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "any");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Polls the data for a sitemap.
     * @param sitemapname sitemap name
     * @param pageid page id
     * @param acceptLanguage language
     * @param subscriptionid subscriptionid
     * @param includeHidden include hidden widgets
     * @param {*} [options] Override http request options.
     */
    public getPageData (sitemapname: string, pageid: string, acceptLanguage?: string, subscriptionid?: string, includeHidden?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/sitemaps/{sitemapname}/{pageid}'
            .replace('{' + 'sitemapname' + '}', encodeURIComponent(String(sitemapname)))
            .replace('{' + 'pageid' + '}', encodeURIComponent(String(pageid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'sitemapname' is not null or undefined
        if (sitemapname === null || sitemapname === undefined) {
            throw new Error('Required parameter sitemapname was null or undefined when calling getPageData.');
        }

        // verify required parameter 'pageid' is not null or undefined
        if (pageid === null || pageid === undefined) {
            throw new Error('Required parameter pageid was null or undefined when calling getPageData.');
        }

        if (subscriptionid !== undefined) {
            localVarQueryParameters['subscriptionid'] = ObjectSerializer.serialize(subscriptionid, "string");
        }

        if (includeHidden !== undefined) {
            localVarQueryParameters['includeHidden'] = ObjectSerializer.serialize(includeHidden, "boolean");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get sitemap by name.
     * @param sitemapname sitemap name
     * @param acceptLanguage language
     * @param type 
     * @param jsoncallback 
     * @param includeHidden include hidden widgets
     * @param {*} [options] Override http request options.
     */
    public getSitemapData (sitemapname: string, acceptLanguage?: string, type?: string, jsoncallback?: string, includeHidden?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/sitemaps/{sitemapname}'
            .replace('{' + 'sitemapname' + '}', encodeURIComponent(String(sitemapname)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'sitemapname' is not null or undefined
        if (sitemapname === null || sitemapname === undefined) {
            throw new Error('Required parameter sitemapname was null or undefined when calling getSitemapData.');
        }

        if (type !== undefined) {
            localVarQueryParameters['type'] = ObjectSerializer.serialize(type, "string");
        }

        if (jsoncallback !== undefined) {
            localVarQueryParameters['jsoncallback'] = ObjectSerializer.serialize(jsoncallback, "string");
        }

        if (includeHidden !== undefined) {
            localVarQueryParameters['includeHidden'] = ObjectSerializer.serialize(includeHidden, "boolean");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get sitemap events.
     * @param subscriptionid subscription id
     * @param sitemap sitemap name
     * @param pageid page id
     * @param {*} [options] Override http request options.
     */
    public getSitemapEvents (subscriptionid: string, sitemap?: string, pageid?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/sitemaps/events/{subscriptionid}'
            .replace('{' + 'subscriptionid' + '}', encodeURIComponent(String(subscriptionid)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'subscriptionid' is not null or undefined
        if (subscriptionid === null || subscriptionid === undefined) {
            throw new Error('Required parameter subscriptionid was null or undefined when calling getSitemapEvents.');
        }

        if (sitemap !== undefined) {
            localVarQueryParameters['sitemap'] = ObjectSerializer.serialize(sitemap, "string");
        }

        if (pageid !== undefined) {
            localVarQueryParameters['pageid'] = ObjectSerializer.serialize(pageid, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all available sitemaps.
     * @param {*} [options] Override http request options.
     */
    public getSitemaps (options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/sitemaps';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum TemplatesApiApiKeys {
}

export class TemplatesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: TemplatesApiApiKeys, value: string) {
        (this.authentications as any)[TemplatesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Get all available templates.
     * @param acceptLanguage language
     * @param {*} [options] Override http request options.
     */
    public getAll (acceptLanguage?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Template;  }> {
        const localVarPath = this.basePath + '/templates';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Template;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Template");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets a template corresponding to the given UID.
     * @param templateUID templateUID
     * @param acceptLanguage language
     * @param {*} [options] Override http request options.
     */
    public getByUID (templateUID: string, acceptLanguage?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Template;  }> {
        const localVarPath = this.basePath + '/templates/{templateUID}'
            .replace('{' + 'templateUID' + '}', encodeURIComponent(String(templateUID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'templateUID' is not null or undefined
        if (templateUID === null || templateUID === undefined) {
            throw new Error('Required parameter templateUID was null or undefined when calling getByUID.');
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Template;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Template");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ThingTypesApiApiKeys {
}

export class ThingTypesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ThingTypesApiApiKeys, value: string) {
        (this.authentications as any)[ThingTypesApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Gets all available thing types without config description, channels and properties.
     * @param acceptLanguage Accept-Language
     * @param {*} [options] Override http request options.
     */
    public getAll (acceptLanguage?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<StrippedThingTypeDTO>;  }> {
        const localVarPath = this.basePath + '/thing-types';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<StrippedThingTypeDTO>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<StrippedThingTypeDTO>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets thing type by UID.
     * @param thingTypeUID thingTypeUID
     * @param acceptLanguage Accept-Language
     * @param {*} [options] Override http request options.
     */
    public getByUID (thingTypeUID: string, acceptLanguage?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ThingTypeDTO;  }> {
        const localVarPath = this.basePath + '/thing-types/{thingTypeUID}'
            .replace('{' + 'thingTypeUID' + '}', encodeURIComponent(String(thingTypeUID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'thingTypeUID' is not null or undefined
        if (thingTypeUID === null || thingTypeUID === undefined) {
            throw new Error('Required parameter thingTypeUID was null or undefined when calling getByUID.');
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ThingTypeDTO;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ThingTypeDTO");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum ThingsApiApiKeys {
}

export class ThingsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ThingsApiApiKeys, value: string) {
        (this.authentications as any)[ThingsApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Creates a new thing and adds it to the registry.
     * @param body thing data
     * @param acceptLanguage language
     * @param {*} [options] Override http request options.
     */
    public create (body: ThingDTO, acceptLanguage?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/things';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling create.');
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ThingDTO")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all available things.
     * @param acceptLanguage language
     * @param {*} [options] Override http request options.
     */
    public getAll (acceptLanguage?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: Array<EnrichedThingDTO>;  }> {
        const localVarPath = this.basePath + '/things';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Array<EnrichedThingDTO>;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "Array<EnrichedThingDTO>");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets thing by UID.
     * @param thingUID thingUID
     * @param acceptLanguage language
     * @param {*} [options] Override http request options.
     */
    public getByUID (thingUID: string, acceptLanguage?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ThingDTO;  }> {
        const localVarPath = this.basePath + '/things/{thingUID}'
            .replace('{' + 'thingUID' + '}', encodeURIComponent(String(thingUID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'thingUID' is not null or undefined
        if (thingUID === null || thingUID === undefined) {
            throw new Error('Required parameter thingUID was null or undefined when calling getByUID.');
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ThingDTO;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ThingDTO");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets thing's config status.
     * @param thingUID thing
     * @param acceptLanguage 
     * @param {*} [options] Override http request options.
     */
    public getConfigStatus (thingUID: string, acceptLanguage?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/things/{thingUID}/config/status'
            .replace('{' + 'thingUID' + '}', encodeURIComponent(String(thingUID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'thingUID' is not null or undefined
        if (thingUID === null || thingUID === undefined) {
            throw new Error('Required parameter thingUID was null or undefined when calling getConfigStatus.');
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets thing's firmware status.
     * @param thingUID thing
     * @param acceptLanguage 
     * @param {*} [options] Override http request options.
     */
    public getFirmwareStatus (thingUID: string, acceptLanguage?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/things/{thingUID}/firmware/status'
            .replace('{' + 'thingUID' + '}', encodeURIComponent(String(thingUID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'thingUID' is not null or undefined
        if (thingUID === null || thingUID === undefined) {
            throw new Error('Required parameter thingUID was null or undefined when calling getFirmwareStatus.');
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get all available firmwares for provided thing UID
     * @param thingUID thingUID
     * @param acceptLanguage Accept-Language
     * @param {*} [options] Override http request options.
     */
    public getFirmwares (thingUID: string, acceptLanguage?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/things/{thingUID}/firmwares'
            .replace('{' + 'thingUID' + '}', encodeURIComponent(String(thingUID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'thingUID' is not null or undefined
        if (thingUID === null || thingUID === undefined) {
            throw new Error('Required parameter thingUID was null or undefined when calling getFirmwares.');
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets thing's status.
     * @param thingUID thing
     * @param acceptLanguage 
     * @param {*} [options] Override http request options.
     */
    public getStatus (thingUID: string, acceptLanguage?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/things/{thingUID}/status'
            .replace('{' + 'thingUID' + '}', encodeURIComponent(String(thingUID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'thingUID' is not null or undefined
        if (thingUID === null || thingUID === undefined) {
            throw new Error('Required parameter thingUID was null or undefined when calling getStatus.');
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Removes a thing from the registry. Set 'force' to __true__ if you want the thing te be removed immediately.
     * @param thingUID thingUID
     * @param acceptLanguage language
     * @param force force
     * @param {*} [options] Override http request options.
     */
    public remove (thingUID: string, acceptLanguage?: string, force?: boolean, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/things/{thingUID}'
            .replace('{' + 'thingUID' + '}', encodeURIComponent(String(thingUID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'thingUID' is not null or undefined
        if (thingUID === null || thingUID === undefined) {
            throw new Error('Required parameter thingUID was null or undefined when calling remove.');
        }

        if (force !== undefined) {
            localVarQueryParameters['force'] = ObjectSerializer.serialize(force, "boolean");
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Sets the thing enabled status.
     * @param thingUID thing
     * @param acceptLanguage 
     * @param body enabled
     * @param {*} [options] Override http request options.
     */
    public setEnabled (thingUID: string, acceptLanguage?: string, body?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/things/{thingUID}/enable'
            .replace('{' + 'thingUID' + '}', encodeURIComponent(String(thingUID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'thingUID' is not null or undefined
        if (thingUID === null || thingUID === undefined) {
            throw new Error('Required parameter thingUID was null or undefined when calling setEnabled.');
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "string")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a thing.
     * @param thingUID thingUID
     * @param body thing
     * @param acceptLanguage language
     * @param {*} [options] Override http request options.
     */
    public update (thingUID: string, body: ThingDTO, acceptLanguage?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ThingDTO;  }> {
        const localVarPath = this.basePath + '/things/{thingUID}'
            .replace('{' + 'thingUID' + '}', encodeURIComponent(String(thingUID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'thingUID' is not null or undefined
        if (thingUID === null || thingUID === undefined) {
            throw new Error('Required parameter thingUID was null or undefined when calling update.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling update.');
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "ThingDTO")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ThingDTO;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ThingDTO");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Updates thing's configuration.
     * @param thingUID thing
     * @param acceptLanguage 
     * @param body configuration parameters
     * @param {*} [options] Override http request options.
     */
    public updateConfiguration (thingUID: string, acceptLanguage?: string, body?: any, options: any = {}) : Promise<{ response: http.IncomingMessage; body: ThingDTO;  }> {
        const localVarPath = this.basePath + '/things/{thingUID}/config'
            .replace('{' + 'thingUID' + '}', encodeURIComponent(String(thingUID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'thingUID' is not null or undefined
        if (thingUID === null || thingUID === undefined) {
            throw new Error('Required parameter thingUID was null or undefined when calling updateConfiguration.');
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "any")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: ThingDTO;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "ThingDTO");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Update thing firmware.
     * @param thingUID thing
     * @param firmwareVersion version
     * @param acceptLanguage language
     * @param {*} [options] Override http request options.
     */
    public updateFirmware (thingUID: string, firmwareVersion: string, acceptLanguage?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/things/{thingUID}/firmware/{firmwareVersion}'
            .replace('{' + 'thingUID' + '}', encodeURIComponent(String(thingUID)))
            .replace('{' + 'firmwareVersion' + '}', encodeURIComponent(String(firmwareVersion)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'thingUID' is not null or undefined
        if (thingUID === null || thingUID === undefined) {
            throw new Error('Required parameter thingUID was null or undefined when calling updateFirmware.');
        }

        // verify required parameter 'firmwareVersion' is not null or undefined
        if (firmwareVersion === null || firmwareVersion === undefined) {
            throw new Error('Required parameter firmwareVersion was null or undefined when calling updateFirmware.');
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum UuidApiApiKeys {
}

export class UuidApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: UuidApiApiKeys, value: string) {
        (this.authentications as any)[UuidApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary A unified unique id.
     * @param {*} [options] Override http request options.
     */
    public getInstanceUUID (options: any = {}) : Promise<{ response: http.IncomingMessage; body: string;  }> {
        const localVarPath = this.basePath + '/uuid';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: string;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    body = ObjectSerializer.deserialize(body, "string");
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum VoiceApiApiKeys {
}

export class VoiceApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: VoiceApiApiKeys, value: string) {
        (this.authentications as any)[VoiceApiApiKeys[key]].apiKey = value;
    }
    /**
     * 
     * @summary Gets the default voice.
     * @param {*} [options] Override http request options.
     */
    public getDefaultVoice (options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/voice/defaultvoice';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Gets a single interpreter.
     * @param id interpreter id
     * @param acceptLanguage language
     * @param {*} [options] Override http request options.
     */
    public getInterpreter (id: string, acceptLanguage?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/voice/interpreters/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getInterpreter.');
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the list of all interpreters.
     * @param acceptLanguage language
     * @param {*} [options] Override http request options.
     */
    public getInterpreters (acceptLanguage?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/voice/interpreters';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Get the list of all voices.
     * @param {*} [options] Override http request options.
     */
    public getVoices (options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/voice/voices';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Sends a text to the default human language interpreter.
     * @param body text to interpret
     * @param acceptLanguage language
     * @param {*} [options] Override http request options.
     */
    public interpret (body: string, acceptLanguage?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/voice/interpreters';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling interpret.');
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "string")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Sends a text to a given human language interpreter.
     * @param body text to interpret
     * @param id interpreter id
     * @param acceptLanguage language
     * @param {*} [options] Override http request options.
     */
    public interpret_1 (body: string, id: string, acceptLanguage?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/voice/interpreters/{id}'
            .replace('{' + 'id' + '}', encodeURIComponent(String(id)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling interpret_1.');
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling interpret_1.');
        }

        localVarHeaderParams['Accept-Language'] = ObjectSerializer.serialize(acceptLanguage, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "string")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * 
     * @summary Speaks a given text with a given voice through the given audio sink.
     * @param body text to speak
     * @param voiceid voice id
     * @param sinkid audio sink id
     * @param {*} [options] Override http request options.
     */
    public say (body: string, voiceid?: string, sinkid?: string, options: any = {}) : Promise<{ response: http.IncomingMessage; body?: any;  }> {
        const localVarPath = this.basePath + '/voice/say';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling say.');
        }

        if (voiceid !== undefined) {
            localVarQueryParameters['voiceid'] = ObjectSerializer.serialize(voiceid, "string");
        }

        if (sinkid !== undefined) {
            localVarQueryParameters['sinkid'] = ObjectSerializer.serialize(sinkid, "string");
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, "string")
        };

        this.authentications.default.applyToRequest(localVarRequestOptions);

        if (Object.keys(localVarFormParams).length) {
            if (localVarUseFormData) {
                (<any>localVarRequestOptions).formData = localVarFormParams;
            } else {
                localVarRequestOptions.form = localVarFormParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body?: any;  }>((resolve, reject) => {
            localVarRequest(localVarRequestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
